# Private Chat Authentication
This document explains how two peers, who are apart of a one-to-one chat, are able to authenticate each other via dMessenger, without a single server or blockchain involved in the process. A/B are the chat participants and use each other's publicly available information (public keys) found within their distributed identity documents (DIDs), to verify each other's identity, prior to proceeding with a private conversation. Applications like Telegram, utilize a central server when attempting to authenticate and exchange keys between two chat participants, while dMessenger does not involve the use of a server in any way.

## How It Works
- A wants to have a private conversation with B, but needs to prove it is speaking with B and when B gets a request from A, it also has to prove that it is indeed speaking with A.

- To initiate the process, A looks up the key on dWeb's DHT that derives from `B` and sends a message to all peers who are swarming `B`, since these peers could all be `B`-related devices.

- In the initial message A uses B's public key (available in B's DID document [see (Identity and User Authentication)[identity-and-user-authentication.md]) to encrypt a message for B containing an identifier of A `A(ID)` (A's username) and a random hash (N1) [nonce], which is used to identify that the transaction is unique. A then encrypts this message with its private key and sends t o B.

##### FORMULA:
`Message = APR(BPU(AID + N1))`

- APR = A's Private Key
- BPU = B's Public Key
- AID = A's Username
- N1 = A's Unique Nonce

- On the event B receives a message over the `B` topic, via the dMessenger UI, a new chat request is shown in the Chat List and a notification is shown on B's device.
- When B opens the new chat request window, there is an accept/deny button. After clicking "Accept", both A/B see "Awaiting Identity Verification" in the private chat window.
- If B clicks "Accept", B decrypts A's message, using A's public key (found in A's DID document) [NOTE: Since the original message sent from A is encrypted using A's private key, it can be decrypted using A's public key], B then decrypts the result using B's private key which should render A's username and the random hash generated by A (N1). 
- B then packages a message back to A, with A's random hash (N1) and a new random hash generated by B (N2). The message is encrypted with A's public key and then encrypted with B's private key, before being sent back to A.

##### FORMULA: 
`Message = BPR(APU(N1 + N2))`

- BPR = B's Private Key
- APU = A's Public Key
- N1 = A's Unique Nonce
- N2 = B's Unique Nonce

- On the event A receives a message back on the `B` topic, A will decrypt it with B's public key, then again with its private key, which should render N1 and N2. 

- A now generates a secret key (`K`), packages it with the N2 received from B and sends `Message = BPU(APR(K + N2))` to B

- On the event that B receives a secret key, B can easily compute the secretKey with `D(APU, D(BPR, M))` and confirm that A has sent back N2 as well.

- Other devices that attempt to pretend to be B could never prove to A that they are B, unless they have B's private key.

- The moment B sends A a message with N1, all other connections with other peers are cancelled.

- dMessenger will insure that new message alerts are only shown to the correct user. For example, A sends a message request to B, attempting to authenticate with B over the `B` topic. C is also swarming the B topic and receives A's request for B. dMessenger will never show this notification to C, since it's not intended for C. C would also be unable to masquerade as B, since it could never decrypt the message.